<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reddi2Drive – Redditch Test Routes (Rotate)</title>

  <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

  <style>
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding: 10px 12px; background:#111; color:#fff; font-weight:700; }
    .controls { padding:10px 12px; background:#f4f4f4; border-bottom:1px solid #ddd; }
    #map { height: calc(100vh - 106px); width:100%; }
    label { display:block; padding:6px 0; }
    .hint { font-size: 12px; color:#555; margin-top:6px; }
  </style>
</head>
<body>
<header>Reddi2Drive – Redditch Test Routes (Two-finger rotate)</header>

<div class="controls">
  <label><input type="checkbox" data-route="redditchroute1.gpx"> Redditch Route 1</label>
  <div class="hint">Use two fingers to rotate the map.</div>
</div>

<div id="map"></div>

<script>
const BOX_FILE = "redditch.box";
const GPX_BASE_PATH = "";
const REDDITCH_CENTER = [-1.945, 52.306];

const map = new maplibregl.Map({
  container: "map",
  style: "https://demotiles.maplibre.org/style.json",
  center: REDDITCH_CENTER,
  zoom: 13,
  bearing: 0,
  pitch: 0,
  dragRotate: true,
  touchZoomRotate: true
});

map.addControl(new maplibregl.NavigationControl(), "top-right");

function fitBounds(bounds) {
  map.fitBounds(bounds, { padding: 40, duration: 500 });
}

function boxToPolygon(swLat, swLng, neLat, neLng) {
  return {
    type: "Feature",
    geometry: {
      type: "Polygon",
      coordinates: [[
        [swLng, swLat],
        [neLng, swLat],
        [neLng, neLat],
        [swLng, neLat],
        [swLng, swLat]
      ]]
    }
  };
}

async function loadBox() {
  const res = await fetch(BOX_FILE);
  const nums = (await res.text()).trim().split(/[\s,]+/).map(Number);
  const [swLat, swLng, neLat, neLng] = nums;
  const feature = boxToPolygon(swLat, swLng, neLat, neLng);

  map.addSource("box", { type: "geojson", data: feature });
  map.addLayer({ id:"box-fill", type:"fill", source:"box", paint:{ "fill-color":"#ff0000", "fill-opacity":0.08 }});
  map.addLayer({ id:"box-line", type:"line", source:"box", paint:{ "line-color":"#ff0000", "line-width":2 }});
  fitBounds([[swLng, swLat],[neLng, neLat]]);
}

async function gpxToGeoJSON(file) {
  const txt = await (await fetch(GPX_BASE_PATH + file)).text();
  const xml = new DOMParser().parseFromString(txt, "text/xml");
  const pts = [...xml.getElementsByTagName("trkpt")].map(p=>[+p.getAttribute("lon"),+p.getAttribute("lat")]);
  return { type:"Feature", geometry:{ type:"LineString", coordinates:pts }};
}

const routes = {};

async function addRoute(file){
  const geo = await gpxToGeoJSON(file);
  map.addSource(file, { type:"geojson", data:geo });
  map.addLayer({ id:file, type:"line", source:file, paint:{ "line-color":"#0066ff","line-width":4 }});
  fitBounds(geo.geometry.coordinates.reduce((b,[x,y])=>[[Math.min(b[0][0],x),Math.min(b[0][1],y)],[Math.max(b[1][0],x),Math.max(b[1][1],y)]],[[180,90],[-180,-90]]));
  routes[file]=true;
}

function removeRoute(file){
  if(routes[file]){
    map.removeLayer(file);
    map.removeSource(file);
    delete routes[file];
  }
}

map.on("load", ()=>{
  loadBox();
  document.querySelectorAll("input[type=checkbox]").forEach(cb=>{
    cb.onchange=()=> cb.checked? addRoute(cb.dataset.route) : removeRoute(cb.dataset.route);
  });
});
</script>
</body>
</html>
