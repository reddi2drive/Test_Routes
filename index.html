<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reddi2Drive – Redditch Test Routes (Rotate)</title>

  <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

  <style>
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding: 10px 12px; background:#111; color:#fff; font-weight:700; }
    .controls { padding:10px 12px; background:#f4f4f4; border-bottom:1px solid #ddd; }
    /* Taller controls now (toggle + dropdown + checkboxes) */
    #map { height: calc(100vh - 250px); width:100%; }

    label { display:block; padding:6px 0; font-weight:600; }
    select { width: 100%; max-width: 520px; padding: 10px; font-size: 16px; }
    .hint { font-size: 12px; color:#555; margin-top:8px; }

    /* Satellite toggle */
    .basemap-row{
      display:flex;
      align-items:center;
      gap:10px;
      padding:6px 0 10px;
      max-width: 520px;
    }
    .basemap-label{ font-weight:700; font-size:14px; }

    .switch{
      position:relative;
      display:inline-block;
      width:52px;
      height:30px;
      flex: 0 0 auto;
    }
    .switch input{
      opacity:0;
      width:0;
      height:0;
    }
    .slider{
      position:absolute;
      cursor:pointer;
      top:0; left:0; right:0; bottom:0;
      background:#cfcfcf;
      transition:.2s;
      border-radius:30px;
    }
    .slider:before{
      position:absolute;
      content:"";
      height:24px;
      width:24px;
      left:3px;
      top:3px;
      background:white;
      transition:.2s;
      border-radius:50%;
      box-shadow:0 1px 4px rgba(0,0,0,.25);
    }
    .switch input:checked + .slider{ background:#2ecc71; }
    .switch input:checked + .slider:before{ transform:translateX(22px); }

    /* Route checkboxes panel (temporary) */
    .route-checks{
      margin-top: 10px;
      max-width: 520px;
      padding: 10px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 10px;
    }
    .route-checks .title{
      font-weight: 800;
      margin-bottom: 6px;
      font-size: 14px;
    }
    .route-checks label{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 6px 0;
      font-weight: 650;
      cursor: pointer;
      user-select: none;
    }
    .route-checks input[type="checkbox"]{
      width: 18px;
      height: 18px;
    }
    .route-checks .sub{
      font-size: 12px;
      color:#666;
      margin-top: 6px;
    }
  </style>
</head>

<body>
  <header>Reddi2Drive – Redditch Test Routes (Two-finger rotate)</header>

  <div class="controls">

    <!-- Satellite toggle -->
    <div class="basemap-row">
      <span class="basemap-label">Streets</span>
      <label class="switch" aria-label="Toggle satellite view">
        <input type="checkbox" id="satToggle">
        <span class="slider"></span>
      </label>
      <span class="basemap-label">Satellite</span>
    </div>

    <label for="routeSelect">Select a route (focus one):</label>
    <select id="routeSelect">
      <option value="">— Choose a route —</option>
      <option value="redditchroute1.gpx">Redditch Route 1</option>
      <option value="redditchroute2.gpx">Redditch Route 2</option>
      <option value="redditchroute3.gpx">Redditch Route 3</option>
      <option value="redditchroute4.gpx">Redditch Route 4</option>
      <option value="redditchroute5.gpx">Redditch Route 5</option>
      <option value="redditchroute6.gpx">Redditch Route 6</option>
      <option value="redditchroute7.gpx">Redditch Route 7</option>
      <option value="redditchroute8.gpx">Redditch Route 8</option>
      <option value="redditchroute9.gpx">Redditch Route 9</option>
      <option value="redditchroute10.gpx">Redditch Route 10</option>
      <option value="redditchroute11.gpx">Redditch Route 11</option>
      <option value="redditchroute12.gpx">Redditch Route 12</option>
      <option value="redditchroute13.gpx">Redditch Route 13</option>
    </select>

    <!-- Google Maps link (only shows when Route 1 is visible) -->
    <div id="gmapsRow" style="max-width:520px; margin-top:10px; display:none;">
      <a id="gmapsLink" href="#" target="_blank" rel="noopener"
         style="display:inline-block; padding:10px 12px; border-radius:10px; background:#1a73e8; color:#fff; text-decoration:none; font-weight:800;">
        Open Route 1 in Google Maps (Drive)
      </a>
    </div>

    <!-- Route checkboxes (temporary) -->
    <div class="route-checks">
      <div class="title">Show multiple routes (temporary)</div>

      <label><input type="checkbox" class="routeCheck" value="redditchroute1.gpx">Redditch Route 1</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute2.gpx">Redditch Route 2</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute3.gpx">Redditch Route 3</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute4.gpx">Redditch Route 4</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute5.gpx">Redditch Route 5</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute6.gpx">Redditch Route 6</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute7.gpx">Redditch Route 7</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute8.gpx">Redditch Route 8</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute9.gpx">Redditch Route 9</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute10.gpx">Redditch Route 10</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute11.gpx">Redditch Route 11</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute12.gpx">Redditch Route 12</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute13.gpx">Redditch Route 13</label>


      <div class="sub">Use these to overlay multiple routes while you check you’re not duplicating sections. You can delete this block when you go live.</div>
    </div>

    <div class="hint">Two fingers to rotate • Two fingers to zoom • One finger to pan</div>
  </div>

  <div id="map"></div>

<script>
  // =====================
  // Hotspots (tap to open Patreon)
  // =====================
  const HOTSPOTS = [
    {
      id: "dunelm-other-road",
      name: "Dunelm / Other Road",
      lat: 52.3068756,
      lng: -1.9349724,
      url: "https://www.patreon.com/posts/139206388?collection=1674521",
      routes: ["redditchroute2.gpx"]
    }
  ];

  // hotspotMarkers: id -> Marker
  const hotspotMarkers = {};
  // hotspotRefCount: id -> number of active routes currently requiring it
  const hotspotRefCount = {};

  function ensureHotspot(h) {
    if (hotspotMarkers[h.id]) return;

    const el = document.createElement("div");
    el.style.width = "14px";
    el.style.height = "14px";
    el.style.borderRadius = "50%";
    el.style.background = "#ff3b30";
    el.style.border = "2px solid #fff";
    el.style.boxShadow = "0 1px 6px rgba(0,0,0,.35)";
    el.style.cursor = "pointer";

    const marker = new maplibregl.Marker(el)
      .setLngLat([h.lng, h.lat])
      .setPopup(
        new maplibregl.Popup({ offset: 18 }).setHTML(`
          <strong>${h.name}</strong><br>
          <a href="${h.url}" target="_blank" rel="noopener">Watch on Patreon</a>
        `)
      )
      .addTo(map);

    hotspotMarkers[h.id] = marker;
  }

  function showHotspotsForRoute(routeFile) {
    HOTSPOTS.forEach(h => {
      if (h.routes && !h.routes.includes(routeFile)) return;

      hotspotRefCount[h.id] = (hotspotRefCount[h.id] || 0) + 1;
      ensureHotspot(h);
    });
  }

  function hideHotspotsForRoute(routeFile) {
    HOTSPOTS.forEach(h => {
      if (!h.routes || !h.routes.includes(routeFile)) return;

      hotspotRefCount[h.id] = (hotspotRefCount[h.id] || 0) - 1;

      if (hotspotRefCount[h.id] <= 0) {
        hotspotRefCount[h.id] = 0;
        if (hotspotMarkers[h.id]) {
          hotspotMarkers[h.id].remove();
          delete hotspotMarkers[h.id];
        }
      }
    });
  }

  // =====================
  // Map setup
  // =====================
  const BOX_FILE = "redditch.box";
  const GPX_BASE_PATH = ""; // "" if GPX files are in repo root, or "routes/" if in /routes/"

  const REDDITCH_CENTER = [-1.945, 52.306]; // [lng, lat]
  const REDDITCH_ZOOM = 13;

  // =====================
  // MapTiler basemaps (Option A)
  // =====================
  const MAPTILER_KEY = "vPQemXBz5sFjnYsmhOyJ";
  const STYLE_STREETS   = `https://api.maptiler.com/maps/streets/style.json?key=${MAPTILER_KEY}`;
  const STYLE_SATELLITE = `https://api.maptiler.com/maps/hybrid/style.json?key=${MAPTILER_KEY}`;

  const map = new maplibregl.Map({
    container: "map",
    style: STYLE_STREETS,
    center: REDDITCH_CENTER,
    zoom: REDDITCH_ZOOM,
    bearing: 0,
    pitch: 0,
    dragRotate: true,
    touchZoomRotate: true,
    maxZoom: 19
  });

  map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), "top-right");

  // =====================
  // Helpers
  // =====================
  function fitToLngLatBounds(bounds, padding = 30) {
    map.fitBounds(bounds, { padding, duration: 600 });
  }

  function boxToPolygonGeoJSON(swLat, swLng, neLat, neLng) {
    const minLng = swLng, minLat = swLat, maxLng = neLng, maxLat = neLat;
    return {
      type: "Feature",
      properties: {},
      geometry: {
        type: "Polygon",
        coordinates: [[
          [minLng, minLat],
          [maxLng, minLat],
          [maxLng, maxLat],
          [minLng, maxLat],
          [minLng, minLat]
        ]]
      }
    };
  }

  function parseGPXTracksToGeoJSON(gpxText) {
    // ONLY raw GPS track points (<trkpt>) – ignores planned routes (<rte>) & waypoints (<wpt>)
    const xml = new DOMParser().parseFromString(gpxText, "text/xml");
    const trksegs = Array.from(xml.getElementsByTagName("trkseg"));

    const lines = [];
    for (const seg of trksegs) {
      const pts = Array.from(seg.getElementsByTagName("trkpt"))
        .map(pt => {
          const lat = Number(pt.getAttribute("lat"));
          const lon = Number(pt.getAttribute("lon"));
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
          return [lon, lat]; // [lng,lat]
        })
        .filter(Boolean);

      if (pts.length >= 2) lines.push(pts);
    }

    if (lines.length === 0) throw new Error("No <trkpt> points found in GPX (raw track).");

    const geom = (lines.length === 1)
      ? { type: "LineString", coordinates: lines[0] }
      : { type: "MultiLineString", coordinates: lines };

    return { type: "Feature", properties: {}, geometry: geom };
  }

  function boundsFromLineCoords(geom) {
    let coords = [];
    if (geom.type === "LineString") coords = geom.coordinates;
    if (geom.type === "MultiLineString") coords = geom.coordinates.flat();

    let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;
    coords.forEach(([lng, lat]) => {
      if (lng < minLng) minLng = lng;
      if (lat < minLat) minLat = lat;
      if (lng > maxLng) maxLng = lng;
      if (lat > maxLat) maxLat = lat;
    });
    return [[minLng, minLat], [maxLng, maxLat]];
  }

  // =====================
  // Box drawing
  // =====================
  async function loadAndDrawBox(refit = true) {
    const res = await fetch(BOX_FILE, { cache: "no-store" });
    if (!res.ok) throw new Error(`Box file not found: ${BOX_FILE}`);

    const text = (await res.text()).trim();
    const nums = text.split(/[\s,]+/).map(Number).filter(n => Number.isFinite(n));
    if (nums.length !== 4) throw new Error("Box file must contain 4 numbers: swLat swLng neLat neLng");

    const [swLat, swLng, neLat, neLng] = nums;
    const feature = boxToPolygonGeoJSON(swLat, swLng, neLat, neLng);
    const bounds = [[swLng, swLat], [neLng, neLat]];

    if (!map.getSource("redditch-box")) {
      map.addSource("redditch-box", { type: "geojson", data: feature });

      map.addLayer({
        id: "redditch-box-fill",
        type: "fill",
        source: "redditch-box",
        paint: { "fill-color": "#ff0000", "fill-opacity": 0.08 }
      });

      map.addLayer({
        id: "redditch-box-line",
        type: "line",
        source: "redditch-box",
        paint: { "line-color": "#ff0000", "line-width": 2 }
      });
    } else {
      map.getSource("redditch-box").setData(feature);
    }

    if (refit) fitToLngLatBounds(bounds, 30);
  }

  // =====================
  // Routes (ref-counted so dropdown + checkboxes can overlap)
  // =====================
  const routes = {};      // filename -> {sourceId, lineId}
  const routeUsage = {};  // filename -> count

  // Google Maps link state (we only expose Route 1 for now)
  const routeGoogleLinks = {}; // filename -> url
  const gmapsRow = document.getElementById("gmapsRow");
  const gmapsLinkEl = document.getElementById("gmapsLink");

  function googleMapsLinkFromFeature(feature) {
    let coords = [];
    if (feature.geometry.type === "LineString") coords = feature.geometry.coordinates;
    if (feature.geometry.type === "MultiLineString") coords = feature.geometry.coordinates.flat();
    if (!coords || coords.length < 2) return null;

    const start = coords[0];               // [lng,lat]
    const end = coords[coords.length - 1]; // [lng,lat]

    const origin = `${start[1]},${start[0]}`;
    const dest   = `${end[1]},${end[0]}`;

    return `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(dest)}&travelmode=driving`;
  }

  function updateGoogleMapsUI() {
    const f = "redditchroute1.gpx";
    const isActive = (routeUsage[f] || 0) > 0;
    const url = routeGoogleLinks[f];

    if (isActive && url) {
      gmapsLinkEl.href = url;
      gmapsRow.style.display = "block";
    } else {
      gmapsLinkEl.href = "#";
      gmapsRow.style.display = "none";
    }
  }

  async function addRoute(filename, fit = true) {
    const url = GPX_BASE_PATH + filename;

    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Couldn’t fetch GPX (${res.status}): ${url}`);

    const gpxText = await res.text();
    const feature = parseGPXTracksToGeoJSON(gpxText);

    // Build Google Maps link for Route 1 (start -> end)
    if (filename === "redditchroute1.gpx") {
      const url = googleMapsLinkFromFeature(feature);
      if (url) routeGoogleLinks[filename] = url;
    }

    const safeName = filename.replace(/[^a-z0-9_-]/gi, "_");
    const sourceId = `route_src_${safeName}`;
    const lineId   = `route_line_${safeName}`;

    if (!map.getSource(sourceId)) {
      map.addSource(sourceId, { type: "geojson", data: feature });

      map.addLayer({
        id: lineId,
        type: "line",
        source: sourceId,
        paint: { "line-color": "#0066ff", "line-width": 4 }
      });
    } else {
      map.getSource(sourceId).setData(feature);
    }

    routes[filename] = { sourceId, lineId };

    if (fit) {
      const bounds = boundsFromLineCoords(feature.geometry);
      fitToLngLatBounds(bounds, 40);
    }
  }

  function removeRoute(filename) {
    const st = routes[filename];
    if (!st) return;
    if (map.getLayer(st.lineId)) map.removeLayer(st.lineId);
    if (map.getSource(st.sourceId)) map.removeSource(st.sourceId);
    delete routes[filename];
  }

  async function activateRoute(filename, { fit } = { fit: true }) {
    routeUsage[filename] = (routeUsage[filename] || 0) + 1;

    if (routeUsage[filename] === 1) {
      await addRoute(filename, fit);
      showHotspotsForRoute(filename);
    } else if (fit) {
      // Route already visible; still allow "fit" when user selects from dropdown
      try { await addRoute(filename, true); } catch (_) {}
    }
    updateGoogleMapsUI();
  }

  function deactivateRoute(filename) {
    if (!routeUsage[filename]) return;

    routeUsage[filename] = routeUsage[filename] - 1;

    if (routeUsage[filename] <= 0) {
      routeUsage[filename] = 0;
      removeRoute(filename);
      hideHotspotsForRoute(filename);
      updateGoogleMapsUI();
    }
    
    updateGoogleMapsUI();
  }


  // =====================
  // UI binding
  // =====================
  let uiBound = false;
  let dropdownRoute = "";

  function bindUIOnce() {
    if (uiBound) return;
    uiBound = true;

    // Dropdown: focus one route at a time (does NOT clear checkbox routes)
    const routeSelect = document.getElementById("routeSelect");
    routeSelect.addEventListener("change", async () => {
      const next = routeSelect.value;

      // Remove the previous dropdown route only
      if (dropdownRoute) {
        deactivateRoute(dropdownRoute);
        dropdownRoute = "";
        updateGoogleMapsUI();
      }

      if (!next) return;

      try {
        await activateRoute(next, { fit: true });
        dropdownRoute = next;
      } catch (e) {
        console.error(e);
        alert("Route didn’t load:\n\n" + e.message);
        routeSelect.value = "";
      }
    });

    // Checkboxes: overlay multiple routes (no auto-fit)
    document.querySelectorAll(".routeCheck").forEach(cb => {
      cb.addEventListener("change", async (e) => {
        const file = e.target.value;
        try {
          if (e.target.checked) {
            await activateRoute(file, { fit: false });
          } else {
            deactivateRoute(file);
          }
        } catch (err) {
          console.error(err);
          alert("Route didn’t load:\n\n" + err.message);
          e.target.checked = false;
        }
      });
    });
  }

  // =====================
  // After style ready (initial load + after switching satellite)
  // =====================
  async function afterStyleReady(refitBox = false) {
    try { await loadAndDrawBox(refitBox); } catch (e) { console.error(e); }
    bindUIOnce();

    // Redraw all currently active routes (routeUsage > 0)
    const active = Object.keys(routeUsage).filter(f => routeUsage[f] > 0);
    for (const f of active) {
      try { await addRoute(f, false); } catch (e) { console.error(e); }
    }

    // Rebuild hotspot markers according to active routes
    // (clear existing markers then re-add based on ref-count)
    Object.keys(hotspotMarkers).forEach(id => {
      hotspotMarkers[id].remove();
      delete hotspotMarkers[id];
    });
    Object.keys(hotspotRefCount).forEach(id => { hotspotRefCount[id] = 0; });

    active.forEach(f => showHotspotsForRoute(f));
    updateGoogleMapsUI();
  }

  map.on("load", () => afterStyleReady(true));

  // =====================
  // Satellite toggle (switch)
  // =====================
  const satToggle = document.getElementById("satToggle");
  satToggle.addEventListener("change", () => {
    const nextStyle = satToggle.checked ? STYLE_SATELLITE : STYLE_STREETS;

    // remember view
    const c = map.getCenter();
    const z = map.getZoom();
    const b = map.getBearing();
    const p = map.getPitch();

    map.setStyle(nextStyle);

    map.once("styledata", async () => {
      // restore view
      map.setCenter(c);
      map.setZoom(z);
      map.setBearing(b);
      map.setPitch(p);

      await afterStyleReady(false);
    });
  });
</script>
</body>
</html>
