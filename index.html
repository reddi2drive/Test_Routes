<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reddi2Drive – Redditch Test Routes</title>

  <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

  
  <style>
    :root{
      --bg:#0b1220;
      --card:#121a2b;
      --text:#eef3ff;
      --muted:#9fb0cc;
      --accent:#4aa3ff;
      --border:rgba(255,255,255,.10);
      --shadow:0 12px 30px rgba(0,0,0,.35);
      --r:16px;
    }

    body {
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    header {
      padding: 12px 14px;
      background:var(--card);
      color:var(--text);
      font-weight:800;
      border-bottom:1px solid var(--border);
      box-shadow: var(--shadow);
    }

    .controls {
      padding:12px 14px;
      background:var(--card);
      border-bottom:1px solid var(--border);
    }

    /* Taller controls now (toggle + dropdown + checkboxes) */
    #map { height: calc(100vh - 250px); width:100%; }

    label { display:block; padding:8px 0 6px; font-weight:700; color:var(--text); }

    select {
      width: 100%;
      max-width: 520px;
      padding: 12px;
      font-size: 16px;
      color:var(--text);
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      border-radius: 12px;
      outline:none;
    }
    select:focus{
      border-color: rgba(74,163,255,0.7);
      box-shadow: 0 0 0 3px rgba(74,163,255,0.20);
    }

    .hint { font-size: 12px; color:var(--muted); margin-top:10px; }
    /* Satellite toggle (bubble – switch matches bubble height) */
    .basemap-row{
      display:flex;
      align-items:center;
      gap:10px;
      max-width:520px;
      background:transparent;   /* removed long white pill */
      border:none;              /* removed border */
      border-radius:0;          /* removed rounding */
      height:auto;              /* let content define height */
      padding:0;                /* no padding */
      box-sizing:border-box;
    }
    .basemap-label{ font-weight:700; font-size:13px; }

    
    .switch{
      position:relative;
      display:inline-block;
      width:64px;
      height:34px;          /* pill height */
      flex: 0 0 auto;
    }
    .switch input{
      opacity:0;
      width:0;
      height:0;
    }
    .slider{
      position:absolute;
      cursor:pointer;
      inset:6px 0 5px 0;  /* shrink pill: 6px top, 5px bottom */
      background:rgba(0,0,0,0.28);
      transition:.18s ease;
      border-radius:999px;
      overflow:hidden;      /* stops any visual bleed */
      box-shadow: inset 0 4px 8px rgba(0,0,0,0.40);
    }
    .slider:before{
      position:absolute;
      content:"";
      width:34px;
      height:31px;          /* thumb increased by 1px */
      left:1px;
      top:2px;              /* lowered by 2px total */              /* lowered by 1px */
      background:#fff;
      transition:.18s ease;
      border-radius:999px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.22);
    }
    .switch input:checked + .slider{ background:rgba(46,204,113,0.7); }
    .switch input:checked + .slider:before{ transform:translateX(28px); }

/* Route checkboxes panel (temporary) */
    .route-checks{
      display: none; /* hide checkboxes (remove this line to show them again) */
      margin-top: 10px;
      max-width: 520px;
      padding: 10px;
      background: rgba(255,255,255,0.04);
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    .route-checks .title{
      font-weight: 800;
      margin-bottom: 6px;
      font-size: 14px;
    }
    .route-checks label{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 6px 0;
      font-weight: 650;
      cursor: pointer;
      user-select: none;
    }
    .route-checks input[type="checkbox"]{
      width: 18px;
      height: 18px;
    }
    .route-checks .sub{
      font-size: 12px;
      color:var(--muted);
      margin-top: 6px;
    }
    .r2d-header{
  display:flex;
  align-items:center;
  justify-content:flex-start;
}

.r2d-brand{
  display:flex;
  align-items:center;
  gap:10px;
}

.r2d-logo{
  width:42px;
  height:42px;
  border-radius:50%;
  object-fit:cover;
  box-shadow:0 0 0 2px rgba(255,255,255,0.15);
}

.r2d-title{
  font-size:1.1rem;
  font-weight:800;
}
 .r2d-tagline{
  margin-top:2px;        /* down 2px */
  margin-left:-2px;      /* left a touch */
  font-size:.8rem;
  font-weight:700;
  letter-spacing:.08em;
  color:var(--muted);

  white-space:nowrap;    /* ✅ keeps it on ONE line */
  overflow:hidden;
  text-overflow:ellipsis; /* optional: stops it wrapping if screen is too narrow */
}

.r2d-word.learn{ color:#e53935; }
.r2d-word.drive{ color:#111;text-shadow:0 0 2px rgba(255,255,255,.65); }
.r2d-word.pass{ color:#fff; }

.r2d-word .two{ color:#9aa0a6; }

.dot{
  margin:0 1px;
  color:var(--muted);
}
    .r2d-header{
  display:flex;
  align-items:center;
  padding:10px 14px;
}

.r2d-left{
  display:flex;
  align-items:flex-start;
  gap:10px;
}

.r2d-logo{
  width:42px;
  height:42px;
  border-radius:50%;
}

.r2d-text{
  display:flex;
  flex-direction:column;
  justify-content:center;
}

.r2d-title-line{
  font-size:1.1rem;
  font-weight:800;
  line-height:1;
  white-space:nowrap; /* FORCE single line */
}

.r2d-tagline{
  margin-top:2px;      /* moves it DOWN 2px */
  margin-left:-2px;   /* pulls it LEFT next to logo */
  font-size:.8rem;
  font-weight:700;
  letter-spacing:.08em;
  color:var(--muted);
}
    .maplibregl-popup-content a{
  color:#000 !important;
  font-weight:700;
  text-decoration:none;
}

.maplibregl-popup-content a:hover{
  text-decoration:underline;
}
    .maplibregl-popup-content strong,
.maplibregl-popup-content b,
.maplibregl-popup-content h3{
  color:#000 !important;
  font-weight:800;
}
    .maplibregl-popup-content h3{
  font-size:15px;
  margin-bottom:4px;
}
  </style>
  
</head>

<body>
<header class="r2d-header">
  <div class="r2d-left">
    <img src="reddi2drivelogo.png" alt="Reddi2Drive Logo" class="r2d-logo">

    <div class="r2d-text">
      <div class="r2d-title-line">
        Reddi<span class="two">2</span>Drive – Test Routes
      </div>

      <div class="r2d-tagline">
        <span class="r2d-word learn">Reddi<span class="two">2</span>Learn</span>
        <span class="dot">|</span>
        <span class="r2d-word drive">Reddi<span class="two">2</span>Drive</span>
        <span class="dot">|</span>
        <span class="r2d-word pass">Reddi<span class="two">2</span>Pass</span>
      </div>
    </div>
  </div>
</header>

  <div class="controls">

    <!-- Satellite toggle -->
    <div class="basemap-row">
      <span class="basemap-label">Map</span>
      <label class="switch" aria-label="Toggle satellite view">
        <input type="checkbox" id="satToggle">
        <span class="slider"></span>
      </label>
      <span class="basemap-label">Satellite</span>
    </div>

    <label for="routeSelect">Select a route:</label>
    <select id="routeSelect">
      <option value="">— Choose a route —</option>
      <option value="redditchroute1.gpx">Redditch Route 1</option>
      <option value="redditchroute2.gpx">Redditch Route 2</option>
      <option value="redditchroute3.gpx">Redditch Route 3</option>
      <option value="redditchroute4.gpx">Redditch Route 4</option>
      <option value="redditchroute5.gpx">Redditch Route 5</option>
      <option value="redditchroute6.gpx">Redditch Route 6</option>
      <option value="redditchroute7.gpx">Redditch Route 7</option>
      <option value="redditchroute8.gpx">Redditch Route 8</option>
      <option value="redditchroute9.gpx">Redditch Route 9</option>
      <option value="redditchroute10.gpx">Redditch Route 10</option>
      <option value="redditchroute11.gpx">Redditch Route 11</option>
      <option value="redditchroute12.gpx">Redditch Route 12</option>
      <option value="redditchroute13.gpx">Redditch Route 13</option>
    </select>

    <!-- OsmAnd download (shows when Route 1 is visible) -->
    <div id="osmandRow" style="max-width:520px; margin-top:10px; display:none;">
      <a id="osmandDownload" href="#" download="redditchroute1.gpx"
         style="display:inline-block; padding:10px 12px; border-radius:10px; background:#1a73e8; color:#fff; text-decoration:none; font-weight:800;">
        Download Route 1 GPX (open in OsmAnd)
      </a>
      <div style="margin-top:6px; font-size:12px; color:var(--muted); line-height:1.35;">
        After it downloads: open the file → Share → choose <b>OsmAnd</b> / <b>Copy to OsmAnd</b>.
      </div>
    </div>

<!-- Route checkboxes (temporary) -->
    <div class="route-checks">
      <div class="title">Show multiple routes (temporary)</div>

      <label><input type="checkbox" class="routeCheck" value="redditchroute1.gpx">Redditch Route 1</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute2.gpx">Redditch Route 2</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute3.gpx">Redditch Route 3</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute4.gpx">Redditch Route 4</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute5.gpx">Redditch Route 5</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute6.gpx">Redditch Route 6</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute7.gpx">Redditch Route 7</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute8.gpx">Redditch Route 8</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute9.gpx">Redditch Route 9</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute10.gpx">Redditch Route 10</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute11.gpx">Redditch Route 11</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute12.gpx">Redditch Route 12</label>
      <label><input type="checkbox" class="routeCheck" value="redditchroute13.gpx">Redditch Route 13</label>


      <div class="sub">Use these to overlay multiple routes while you check you’re not duplicating sections. You can delete this block when you go live.</div>
    </div>

    <div class="hint">Two fingers to rotate • Two fingers to zoom • One finger to pan</div>
  </div>

  <div id="map"></div>

<script>
  // =====================
  // Hotspots (tap to open Patreon)
  // =====================
  const HOTSPOTS = [
    {
      id: "dunelm-other-road",
      name: "Dunelm / Other Road",
      lat: 52.3068756,
      lng: -1.9349724,
      url: "https://www.patreon.com/posts/139206388?collection=1674521",
      routes: ["redditchroute2.gpx"]
    },
    {
      id: "prospect hill",
      name: "Prospect Hill",
      lat: 52.3086451,
      lng: -1.9403938,
      url: "https://www.patreon.com/posts/137427199?collection=1675168",
      routes: ["redditchroute2.gpx"]
    }
  ];

  // hotspotMarkers: id -> Marker
  const hotspotMarkers = {};
  // hotspotRefCount: id -> number of active routes currently requiring it
  const hotspotRefCount = {};

  function ensureHotspot(h) {
    if (hotspotMarkers[h.id]) return;

    const el = document.createElement("div");
    el.style.width = "14px";
    el.style.height = "14px";
    el.style.borderRadius = "50%";
    el.style.background = "#ff3b30";
    el.style.border = "2px solid #fff";
    el.style.boxShadow = "0 1px 6px rgba(0,0,0,.35)";
    el.style.cursor = "pointer";

    const marker = new maplibregl.Marker(el)
      .setLngLat([h.lng, h.lat])
      .setPopup(
        new maplibregl.Popup({ offset: 18 }).setHTML(`
          <strong>${h.name}</strong><br>
          <a href="${h.url}" target="_blank" rel="noopener">Watch on Patreon</a>
        `)
      )
      .addTo(map);

    hotspotMarkers[h.id] = marker;
  }

  function showHotspotsForRoute(routeFile) {
    HOTSPOTS.forEach(h => {
      if (h.routes && !h.routes.includes(routeFile)) return;

      hotspotRefCount[h.id] = (hotspotRefCount[h.id] || 0) + 1;
      ensureHotspot(h);
    });
  }

  function hideHotspotsForRoute(routeFile) {
    HOTSPOTS.forEach(h => {
      if (!h.routes || !h.routes.includes(routeFile)) return;

      hotspotRefCount[h.id] = (hotspotRefCount[h.id] || 0) - 1;

      if (hotspotRefCount[h.id] <= 0) {
        hotspotRefCount[h.id] = 0;
        if (hotspotMarkers[h.id]) {
          hotspotMarkers[h.id].remove();
          delete hotspotMarkers[h.id];
        }
      }
    });
  }

  // =====================
  // Map setup
  // =====================
  const BOX_FILE = "redditch.box";
  const GPX_BASE_PATH = ""; // "" if GPX files are in repo root, or "routes/" if in /routes/"

  const REDDITCH_CENTER = [-1.945, 52.306]; // [lng, lat]
  const REDDITCH_ZOOM = 13;

  // =====================
  // MapTiler basemaps (Option A)
  // =====================
  const MAPTILER_KEY = "vPQemXBz5sFjnYsmhOyJ";
  const STYLE_STREETS   = `https://api.maptiler.com/maps/streets/style.json?key=${MAPTILER_KEY}`;
  const STYLE_SATELLITE = `https://api.maptiler.com/maps/hybrid/style.json?key=${MAPTILER_KEY}`;

  const map = new maplibregl.Map({
    container: "map",
    style: STYLE_STREETS,
    center: REDDITCH_CENTER,
    zoom: REDDITCH_ZOOM,
    bearing: 0,
    pitch: 0,
    dragRotate: true,
    touchZoomRotate: true,
    maxZoom: 19
  });

  map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), "top-right");

  // =====================
  // Helpers
  // =====================
  function fitToLngLatBounds(bounds, padding = 30) {
    map.fitBounds(bounds, { padding, duration: 600 });
  }

  function boxToPolygonGeoJSON(swLat, swLng, neLat, neLng) {
    const minLng = swLng, minLat = swLat, maxLng = neLng, maxLat = neLat;
    return {
      type: "Feature",
      properties: {},
      geometry: {
        type: "Polygon",
        coordinates: [[
          [minLng, minLat],
          [maxLng, minLat],
          [maxLng, maxLat],
          [minLng, maxLat],
          [minLng, minLat]
        ]]
      }
    };
  }

  function parseGPXTracksToGeoJSON(gpxText) {
    // ONLY raw GPS track points (<trkpt>) – ignores planned routes (<rte>) & waypoints (<wpt>)
    const xml = new DOMParser().parseFromString(gpxText, "text/xml");
    const trksegs = Array.from(xml.getElementsByTagName("trkseg"));

    const lines = [];
    for (const seg of trksegs) {
      const pts = Array.from(seg.getElementsByTagName("trkpt"))
        .map(pt => {
          const lat = Number(pt.getAttribute("lat"));
          const lon = Number(pt.getAttribute("lon"));
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
          return [lon, lat]; // [lng,lat]
        })
        .filter(Boolean);

      if (pts.length >= 2) lines.push(pts);
    }

    if (lines.length === 0) throw new Error("No <trkpt> points found in GPX (raw track).");

    const geom = (lines.length === 1)
      ? { type: "LineString", coordinates: lines[0] }
      : { type: "MultiLineString", coordinates: lines };

    return { type: "Feature", properties: {}, geometry: geom };
  }

  function boundsFromLineCoords(geom) {
    let coords = [];
    if (geom.type === "LineString") coords = geom.coordinates;
    if (geom.type === "MultiLineString") coords = geom.coordinates.flat();

    let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;
    coords.forEach(([lng, lat]) => {
      if (lng < minLng) minLng = lng;
      if (lat < minLat) minLat = lat;
      if (lng > maxLng) maxLng = lng;
      if (lat > maxLat) maxLat = lat;
    });
    return [[minLng, minLat], [maxLng, maxLat]];
  }

  // =====================
  // Route smoothing (reduces jagged GPS noise)
  // =====================
  // Tolerance is in degrees. For UK driving routes:
  // 0.00002 = light, 0.00003 = medium, 0.00005 = strong
  const ROUTE_SIMPLIFY_TOLERANCE = 0.00003;

  function simplifyDouglasPeucker(points, tolerance) {
    if (!points || points.length <= 2) return points || [];
    const sqTol = tolerance * tolerance;

    function getSqSegDist(p, p1, p2) {
      let x = p1[0], y = p1[1];
      let dx = p2[0] - x, dy = p2[1] - y;

      if (dx !== 0 || dy !== 0) {
        const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx*dx + dy*dy);
        if (t > 1) { x = p2[0]; y = p2[1]; }
        else if (t > 0) { x += dx * t; y += dy * t; }
      }

      dx = p[0] - x; dy = p[1] - y;
      return dx*dx + dy*dy;
    }

    function simplifyDP(pts, first, last, sqTol, out) {
      let maxSqDist = sqTol;
      let index = -1;

      for (let i = first + 1; i < last; i++) {
        const sqDist = getSqSegDist(pts[i], pts[first], pts[last]);
        if (sqDist > maxSqDist) {
          index = i;
          maxSqDist = sqDist;
        }
      }

      if (index !== -1) {
        if (index - first > 1) simplifyDP(pts, first, index, sqTol, out);
        out.push(pts[index]);
        if (last - index > 1) simplifyDP(pts, index, last, sqTol, out);
      }
    }

    const out = [points[0]];
    simplifyDP(points, 0, points.length - 1, sqTol, out);
    out.push(points[points.length - 1]);
    return out;
  }

  function smoothGeometry(geometry) {
    if (!geometry) return geometry;

    if (geometry.type === "LineString") {
      const coords = geometry.coordinates || [];
      const sm = simplifyDouglasPeucker(coords, ROUTE_SIMPLIFY_TOLERANCE);
      return { ...geometry, coordinates: sm };
    }

    if (geometry.type === "MultiLineString") {
      const lines = geometry.coordinates || [];
      const smLines = lines.map(line => simplifyDouglasPeucker(line, ROUTE_SIMPLIFY_TOLERANCE));
      return { ...geometry, coordinates: smLines };
    }

    return geometry;
  }

  // =====================
  // Box drawing
  // =====================
  async function loadAndDrawBox(refit = true) {
    const res = await fetch(BOX_FILE, { cache: "no-store" });
    if (!res.ok) throw new Error(`Box file not found: ${BOX_FILE}`);

    const text = (await res.text()).trim();
    const nums = text.split(/[\s,]+/).map(Number).filter(n => Number.isFinite(n));
    if (nums.length !== 4) throw new Error("Box file must contain 4 numbers: swLat swLng neLat neLng");

    const [swLat, swLng, neLat, neLng] = nums;
    const feature = boxToPolygonGeoJSON(swLat, swLng, neLat, neLng);
    const bounds = [[swLng, swLat], [neLng, neLat]];

    if (!map.getSource("redditch-box")) {
      map.addSource("redditch-box", { type: "geojson", data: feature });

      map.addLayer({
        id: "redditch-box-fill",
        type: "fill",
        source: "redditch-box",
        paint: { "fill-color": "#ff0000", "fill-opacity": 0.08 }
      });

      map.addLayer({
        id: "redditch-box-line",
        type: "line",
        source: "redditch-box",
        paint: { "line-color": "#ff0000", "line-width": 2 }
      });
    } else {
      map.getSource("redditch-box").setData(feature);
    }

    if (refit) fitToLngLatBounds(bounds, 30);
  }

  // =====================
  // Routes (ref-counted so dropdown + checkboxes can overlap)
  // =====================
  const routes = {};      // filename -> {sourceId, lineId}
  const routeUsage = {};  // filename -> count

  // OsmAnd download state (Route 1)
  const osmandRow = document.getElementById("osmandRow");
  const osmandDownloadEl = document.getElementById("osmandDownload");

  function gpxAbsoluteUrl(filename) {
    // Absolute URL to GPX file (works on GitHub Pages + custom domain)
    return new URL(GPX_BASE_PATH + filename, window.location.href).href;
  }

  function updateOsmAndUI() {
    const f = "redditchroute1.gpx";
    const isActive = (routeUsage[f] || 0) > 0;

    if (isActive) {
      osmandDownloadEl.href = gpxAbsoluteUrl(f);
      osmandRow.style.display = "block";
    } else {
      osmandDownloadEl.href = "#";
      osmandRow.style.display = "none";
    }
  }

  async function addRoute(filename, fit = true) {
    const url = GPX_BASE_PATH + filename;

    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Couldn’t fetch GPX (${res.status}): ${url}`);

    const gpxText = await res.text();
    const feature = parseGPXTracksToGeoJSON(gpxText);

    // Smooth the geometry to reduce jagged GPS noise
    feature.geometry = smoothGeometry(feature.geometry);

    const safeName = filename.replace(/[^a-z0-9_-]/gi, "_");
    const sourceId = `route_src_${safeName}`;
    const lineId   = `route_line_${safeName}`;

    if (!map.getSource(sourceId)) {
      map.addSource(sourceId, { type: "geojson", data: feature });

      map.addLayer({
        id: lineId,
        type: "line",
        source: sourceId,
        layout: { "line-join": "round", "line-cap": "round" },
        paint: { "line-color": "#0066ff", "line-width": 4 }
      });
    } else {
      map.getSource(sourceId).setData(feature);
    }

    routes[filename] = { sourceId, lineId };

    if (fit) {
      const bounds = boundsFromLineCoords(feature.geometry);
      fitToLngLatBounds(bounds, 40);
    }
  }

  function removeRoute(filename) {
    const st = routes[filename];
    if (!st) return;
    if (map.getLayer(st.lineId)) map.removeLayer(st.lineId);
    if (map.getSource(st.sourceId)) map.removeSource(st.sourceId);
    delete routes[filename];
  }

  async function activateRoute(filename, { fit } = { fit: true }) {
    routeUsage[filename] = (routeUsage[filename] || 0) + 1;

    if (routeUsage[filename] === 1) {
      await addRoute(filename, fit);
      showHotspotsForRoute(filename);
    } else if (fit) {
      // Route already visible; still allow "fit" when user selects from dropdown
      try { await addRoute(filename, true); } catch (_) {}
    }
    updateOsmAndUI();
  }

  function deactivateRoute(filename) {
    if (!routeUsage[filename]) return;

    routeUsage[filename] = routeUsage[filename] - 1;

    if (routeUsage[filename] <= 0) {
      routeUsage[filename] = 0;
      removeRoute(filename);
      hideHotspotsForRoute(filename);
      updateOsmAndUI();
    }
    
    updateOsmAndUI();
  }


  // =====================
  // UI binding
  // =====================
  let uiBound = false;
  let dropdownRoute = "";

  function bindUIOnce() {
    if (uiBound) return;
    uiBound = true;

    // Dropdown: focus one route at a time (does NOT clear checkbox routes)
    const routeSelect = document.getElementById("routeSelect");
    routeSelect.addEventListener("change", async () => {
      const next = routeSelect.value;

      // Remove the previous dropdown route only
      if (dropdownRoute) {
        deactivateRoute(dropdownRoute);
        dropdownRoute = "";
        updateOsmAndUI();
      }

      if (!next) return;

      try {
        await activateRoute(next, { fit: true });
        dropdownRoute = next;
      } catch (e) {
        console.error(e);
        alert("Route didn’t load:\n\n" + e.message);
        routeSelect.value = "";
      }
    });

    // Checkboxes: overlay multiple routes (no auto-fit)
    document.querySelectorAll(".routeCheck").forEach(cb => {
      cb.addEventListener("change", async (e) => {
        const file = e.target.value;
        try {
          if (e.target.checked) {
            await activateRoute(file, { fit: false });
          } else {
            deactivateRoute(file);
          }
        } catch (err) {
          console.error(err);
          alert("Route didn’t load:\n\n" + err.message);
          e.target.checked = false;
        }
      });
    });
  }

  // =====================
  // After style ready (initial load + after switching satellite)
  // =====================
  async function afterStyleReady(refitBox = false) {
    try { await loadAndDrawBox(refitBox); } catch (e) { console.error(e); }
    bindUIOnce();

    // Redraw all currently active routes (routeUsage > 0)
    const active = Object.keys(routeUsage).filter(f => routeUsage[f] > 0);
    for (const f of active) {
      try { await addRoute(f, false); } catch (e) { console.error(e); }
    }

    // Rebuild hotspot markers according to active routes
    // (clear existing markers then re-add based on ref-count)
    Object.keys(hotspotMarkers).forEach(id => {
      hotspotMarkers[id].remove();
      delete hotspotMarkers[id];
    });
    Object.keys(hotspotRefCount).forEach(id => { hotspotRefCount[id] = 0; });

    active.forEach(f => showHotspotsForRoute(f));
    updateOsmAndUI();
  }

  map.on("load", () => afterStyleReady(true));

  // =====================
  // Satellite toggle (switch)
  // =====================
  const satToggle = document.getElementById("satToggle");
  satToggle.addEventListener("change", () => {
    const nextStyle = satToggle.checked ? STYLE_SATELLITE : STYLE_STREETS;

    // remember view
    const c = map.getCenter();
    const z = map.getZoom();
    const b = map.getBearing();
    const p = map.getPitch();

    map.setStyle(nextStyle);

    map.once("styledata", async () => {
      // restore view
      map.setCenter(c);
      map.setZoom(z);
      map.setBearing(b);
      map.setPitch(p);

      await afterStyleReady(false);
    });
  });
</script>
</body>
</html>
